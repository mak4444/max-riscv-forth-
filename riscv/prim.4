
CODE 1+
	addi	a0,a0,1
	ret
END-CODE

CODE 2+
	addi	a0,a0,2
	ret
END-CODE

CODE CELL+
	addi	a0,a0,4
	ret
END-CODE	

CODE CELL-
	addi	a0,a0,-4
	ret
END-CODE	

CODE 2-
	addi	a0,a0,-2
	ret
END-CODE

CODE ?DUP
	beqz	a0,0f
CODL DUP
	DUP,
0:	ret
END-CODE	

CODE DROP
	lw	a0,(s0)
CODL NIP
	addi	s0,s0,4
	ret
END-CODE	

CODE OVER
	DUP,
	lw	a0,4(s0)
	ret
END-CODE	

' OVER	TO 'OVER

CODE SWAP
	lw	a1,(s0)
	sw	a0,(s0)
	mv	a0, a1	
	ret
END-CODE	

CODE ROT	( n2 n1 n0 -- n1 n0 n2 )
	lw	a1,(s0)
	lw	a2,4(s0)
	sw	a1,4(s0)
	sw	a0,(s0)
	mv	a0, a2
	ret
END-CODE	

CODE -ROT	( n2 n1 n0 -- n0 n2 n1 )
	lw	a1,(s0)
	lw	a2,4(s0)
	sw	a0,4(s0)
	sw	a2,(s0)
	mv	a0, a1
	ret
END-CODE	

CODE 2NIP
	lw	a1,(s0)
	addi s0,s0,8
	sw	a1,(s0)	
	ret
END-CODE	

CODE 2SWAP	(  n3 n2 n1 n0 -- n1 n0 n3 n2  )
CODL CS-SWAP
	lw	a1,(s0)
	lw	a2,4(s0)
	lw	a3,8(s0)
	sw	a3,(s0)
	sw	a0,4(s0)
	sw	a1,8(s0)
	mv	a0, a2
	ret
END-CODE	


CODE PICK	( Nm,...,N1,K -- Nm,...,N1,Nk )
	slli	a0,a0,2
	add	a0,a0,s0
	lw	a0,(a0)
	ret
END-CODE

CODE +
	lw	a1,0(s0)
	add	a0,a0,a1
	addi	s0,s0,4
	ret
END-CODE

CODE -
	lw	a1,0(s0)
	sub	a0,a1,a0
	addi	s0,s0,4
	ret
END-CODE

CODE D+
	lw	a2,8(s0)
	lw	a3,4(s0)
	lw	a1,0(s0)
		add    a1, a1,a2
		sltu   a4, a1,a2  # R4 is carry
		add    a0, a0,a3
		add    a0, a0,a4
	sw	a1,8(s0)
	addi s0,s0,8
	ret
END-CODE

\ Forth UM+      ( n1 n2 -- sum cflag )
\  Add two numbers, return the sum and carry flag.
CODE UM+
	lw	a1,(s0)
		add    a1, a1,a0
		sltu   a0, a1,a0  # R0 is carry
	sw	a2,(s0)
	ret
END-CODE

CODE UM* ( u1 u2 -- ud ) \ 94
\ ud - произведение u1 и u2. Все значения и арифметика беззнаковые.
	lw	a1,(s0)
		mul	a2, a0,a1
		mulhu	a0, a0,a1
	sw	a2,(s0)
	ret
END-CODE

CODE DNEGATE  ( d -- -d )

	lw	a1,(s0)
		neg a1, a1
		sltu a3, zero, a1   # R3 is borrow
		neg a0, a0
		sub a0,a0,a3
	sw	a1,(s0)
	ret
END-CODE

CODE *
	lw	a1,0(s0)
	mul	a0,a0,a1
	addi	s0,s0,4
	ret
END-CODE

CODE /
	lw		a1,0(s0)
	div		a0,a1,a0
	addi	s0,s0,4
	ret
END-CODE

CODE U/
	lw		a1,0(s0)
	divu	a0,a1,a0
	addi	s0,s0,4
	ret
END-CODE

CODE MOD
	lw		a1,0(s0)
	rem		a0,a1,a0
	addi	s0,s0,4
	ret
END-CODE

CODE OR
	lw		a1,0(s0)
	or		a0,a0,a1
	addi	s0,s0,4
	ret
END-CODE	

CODE XOR
	lw	a1,0(s0)
	xor	a0,a0,a1
	addi	s0,s0,4
	ret
END-CODE	

CODE ANDC
	not	a0,a0
CODL AND
	lw	a1,0(s0)
	and	a0,a0,a1
	addi	s0,s0,4
	ret
END-CODE	

CODE LSHIFT
CODL <<
	lw	a1,0(s0)
	SLL	a0, a1, a0
	addi	s0,s0,4
	ret
END-CODE	

CODE RSHIFT
CODL >>
	lw	a1,0(s0)
	SRL	a0, a1, a0
	addi	s0,s0,4
	ret
END-CODE	

CODE ARSHIFT
CODL A>>
	lw	a1,0(s0)
	SRA	a0, a1, a0
	addi	s0,s0,4
	ret
END-CODE	

CODE 16*
	slli    a0, a0, 4
	ret
END-CODE	

CODE 2*
	slli    a0, a0, 1
	ret
END-CODE	

CODE CELLS
	slli    a0, a0, 2
	ret
END-CODE	

CODE U16/
	srli    a0, a0, 4
	ret
END-CODE	

CODE U2/
	srli    a0, a0, 1
	ret
END-CODE

CODE 2/
	SRAI    a0, a0, 1
	ret
END-CODE

CODE @
	lw	a0,(a0)
	ret
END-CODE

CODE W@
	lhu	a0,(a0)
	ret
END-CODE

CODE CDR
	lw	a0,-4(a0)
	ret
END-CODE

CODE NAME>F
	addi	a0,a0,-8
	ret
END-CODE

CODE NAME>C
	addi	a0,a0,-0xC
	ret
END-CODE

CODE NAME>
	lw	a0,-0xC(a0)
	ret
END-CODE


CODE !
	lw	a1,(s0)
	sw	a1,(a0)
CODL 2DROP
	lw	a0,4(s0)
	addi s0,s0,8
	ret
END-CODE

CODE W!
	lw	a1,(s0)
	sh	a1,(a0)
	lw	a0,4(s0)
	addi s0,s0,8
	ret
END-CODE

CODE C!
	lw	a1,(s0)
	sb	a1,(a0)
	lw	a0,4(s0)
	addi s0,s0,8
	ret
END-CODE

CODE ON
	li	a1,-1
	sw	a1,(a0)
	DROP,
	ret
END-CODE

CODE OFF
CODL 0!
	sw	zero,(a0)
	DROP,
	ret
END-CODE


\  If n1 is equal to n2, return TRUE. Otherwise FALSE.
CODE =		( a b -- f )
	lw	a1,0(s0)
	xor	a0,a0,a1
	addi	s0,s0,4
\  If n is equal to 0, return TRUE. Otherwise FALSE.
CODL 0=		( a -- f )
	seqz	a0,a0
CODL NEGATE	
	neg	a0,a0
	ret
END-CODE

CODE 0<	( n -- F )
	srai    a0, a0, 0x1f
	ret
END-CODE

\ If n1 is not equal to n2, return TRUE.  Otherwise FALSE.
CODE <>		( a b -- f )
	lw	a1,0(s0)
	xor	a0,a0,a1
	addi	s0,s0,4
\ If n is not equal to 0, return TRUE.  Otherwise FALSE.
CODL 0<>	( a -- F )
	seqz	a0,a0
CODL 1-	
	addi	a0,a0,-1
	ret
END-CODE

CODE <	( a b -- F )
	lw	a1,0(s0)
	SLT a0, a1, a0
	neg a0,a0
	addi	s0,s0,4
	ret
END-CODE

CODE >	( a b -- F )
	lw	a1,0(s0)
	SLT a0, a0, a1
	neg a0,a0
	addi	s0,s0,4
	ret
END-CODE

CODE U<	( a b -- F )
	lw	a1,0(s0)
	SLTU a0, a1, a0
	neg a0,a0
	addi	s0,s0,4
	ret
END-CODE

CODE U>	( a b -- F )
	lw	a1,0(s0)
	SLTU a0, a0, a1
	neg a0,a0
	addi	s0,s0,4
	ret
END-CODE

CODE 0MAX	( a b -- F )
	bltz	a0, 0f
	li		a0,0
0:	ret
END-CODE

CODE MIN	( a b -- F )
	lw		a1,0(s0)
	addi	s0,s0,4
	blt		a0, a1, 0f
	mv		a0,a1
0:	ret
END-CODE

CODE MAX	( a b -- F )
	lw		a1,0(s0)
	addi	s0,s0,4
	blt		a1, a0, 0f
	mv		a0,a1
0:	ret
END-CODE

CODE UMAX	( a b -- F )
	lw		a1,0(s0)
	addi	s0,s0,4
	bltu	a1, a0, 0f
	mv		a0,a1
0:	ret
END-CODE

CODE UMIN	( a b -- F )
	lw		a1,0(s0)
	addi	s0,s0,4
	bltu	a0, a1, 0f
	mv		a0,a1
0:	ret
END-CODE

CODE ABS	( a b -- F )
	blt	zero,a0, 0f
	neg	a0,a0
0:	ret
END-CODE	

CODE COUNT	( a -- a+1 c ) 
	DUP,
	addi	a1,a0,1
	sw	a1,0(s0)
CODL C@
	lbu	a0,(a0)
	ret
END-CODE

CODE PERFORM	( ... [tx] -- ...' )
CODL @EXECUTE
	lw	a0,(a0)
\ Execute the word whose CFA is on the stack
CODL EXECUTE	( ... tx -- ...' )
	mv	a1, a0
	lw	a0,(s0) \ drop
	addi	s0,s0,4
	jr	a1
END-CODE

CODE SP@
	DUP,
	mv	a0,s0
	ret
END-CODE

CODE SP!
	addi	s0,a0,4
	lw		a0,-4(s0)
	ret
END-CODE

CODE RP@
	DUP,
	mv	a0,sp
	ret
END-CODE

CODE RP!
	mv	sp,a0
	DROP,
	ret
END-CODE

CODE DUP>R	( N -- N )
	addi	sp,sp,-4
	sw		a0,0(sp)
	ret
END-CODE

CODE >R	( N --  )
	addi	sp,sp,-4
	sw		a0,0(sp)
	DROP,
	ret
END-CODE

CODE R@	( N -- N )
	DUP,
	lw		a0,0(sp)
	ret
END-CODE

CODE R>	( N -- N )
	DUP,
	lw		a0,0(sp)
CODL RDROP	
	addi	sp,sp,4
	ret
END-CODE

CODE 2>R	( N --  )
	addi	sp,sp,-8
	sw	a0,0(sp)
	lw	a0,0(s0)
	sw	a0,4(sp)
	lw	a0,4(s0)
	addi	s0,s0,8
	ret
END-CODE

CODE 2R@	( N -- N )
	addi	s0,s0,8
	sw	a0,4(s0)
	lw	a0,4(sp)
	sw	a0,0(s0)
	lw	a0,0(sp)
	ret
END-CODE

CODE 2R>	( N -- N )
	addi	s0,s0,-8
	sw	a0,4(s0)
	lw	a0,4(sp)
	sw	a0,0(s0)
	lw	a0,0(sp)
	
CODL 2RDROP	
	addi	sp,sp,8
	ret
END-CODE

CODE DOVECT
	lw	a1,(a1)
	jr	a1
END-CODE 

' DOVECT TO 'DOVECT

CODE DOCREATE
	DUP,
	mv	a0,a1
	ret
END-CODE

CODE DOVALUE
	nop
CODL DOCONSTANT
	DUP,
	lw	a0,(a1)
	ret
END-CODE

' DOVALUE TO 'DOVALUE
' DOCONSTANT TO 'DOCONSTANT

CODE I
	DUP,
	mv	a0,s1
	ret
END-CODE
	
CODE (?DO) (  limit index -- )
	lw		a1,0(s0)
	beq		a0,a1,0f	\ index = limit
CODL (DO) (  limit index -- )
	addi	sp,sp,-0xC
	sw		ra, 8(sp)	\ return is exit address link
	sw		s11, 4(sp)	\ s11 = old index - limit - msb
	sw		s1, (sp)	\ s1 = old index     

	lw		a1,0(s0)	\ a1 = index
	sub		s11,a0,a1	\ s11 = index - limit 
	li		a1,0x80000000
	or		s11,s11,a1
	mv		s1,a0 	\ s1 = index

	lw	a0,4(s0)	\ 2drop
	addi s0,s0,8

	addi	ra,ra,4
	ret
0:
	lw	a0,4(s0)	\ 2drop
	addi s0,s0,8

	lw		ra, (ra)	\ return is exit address link
	ret
END-CODE

' (?DO) TO '(?DO)
' (DO) TO '(DO)

CODE UNLOOP
	lw	s11,4(sp)
	lw	s1,0(sp)
	addi	sp,sp,12
	ret
END-CODE


CODE EMIT
	addi	sp,sp,-4
	sw	ra,0(sp)
	
    li a1, UART_BASE
    call ' putc
	
	lw	a0,0(s0) \ drop
	addi	s0,s0,4
	
	lw	ra,0(sp)
	addi	sp,sp,4
	ret
END-CODE	

CODE KEY
	addi	sp,sp,-4
	sw	ra,0(sp)
	
	DUP,
	li a0, UART_BASE
	call ' getc_block         # char in a0
	
	lw	ra,0(sp)
	addi	sp,sp,4
	ret
END-CODE	

CODE CMOVE
	beqz	a0, 0f
	lw	a2, 4(s0)	#source
	lw	a1, (s0)	#count
1:	lb	a3, 0(a2)
        addi	a2, a2, 1 
        sb	a3, 0(a1)
        addi	a1, a1, 1 
        addi	a0, a0, -1
        bnez	a0, 1b
0:	lw	a0, 8(s0)
        addi	s0, s0, 0xC	
	ret
END-CODE	
