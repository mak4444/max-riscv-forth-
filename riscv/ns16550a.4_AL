
0 [if]
CODE TCT

	bltz	x28,here
	bltz	s11,here
	bltz	t3,here

	li	a0,0x800
	jal	ra, here 0x80F6	-
____:	002000ef          	jal	ra,    0x2 here +
____:	004000ef          	jal	ra,    0x4 here +
____:	008000ef          	jal	ra,    0x8 here +
____:	010000ef          	jal	ra,   0x10 here +
____:	020000ef          	jal	ra,   0x20 here +
____:	040000ef          	jal	ra,   0x40 here +
____:	080000ef          	jal	ra,   0x80 here +
____:	100000ef          	jal	ra,  0x100 here +
____:	200000ef          	jal	ra,  0x200 here +
____:	400000ef          	jal	ra,  0x400 here +
____:	001000ef          	jal	ra,  0x800 here +
____:	000010ef          	jal	ra, 0x1000 here +
____:	000020ef          	jal	ra, 0x2000 here +
____:	000040ef          	jal	ra, 0x4000 here +
____:	000080ef          	jal	ra, 0x8000 here +
____:	000100ef          	jal	ra,0x10000 here +
____:	000200ef          	jal	ra,0x20000 here +
____:	000400ef          	jal	ra,0x40000 here +
____:	000800ef          	jal	ra,0x80000 here +
END-CODE
\eof

	beq		a0,a1,.+  0x1
	beq		a0,a1,.+  0x2
	beq		a0,a1,.+  0x4
	beq		a0,a1,.+  0x8
	beq		a0,a1,.+ 0x10
	beq		a0,a1,.+ 0x20
	beq		a0,a1,.+ 0x40
	beq		a0,a1,.+ 0x80
	beq		a0,a1,.+0x100
	beq		a0,a1,.+0x200
	beq		a0,a1,.+0x400
	beq		a0,a1,.+0x800


[then]


#define UART_REG_TRANSMIT 0
#define UART_REG_RECEIVE 0
#define UART_REG_FCR 2
#define UART_REG_LCR 3 
#define UART_REG_LSR 5
#define UART_REG_IER 0x1

#define UART_REG_FCF_FIFOENABLE 1
#define UART_REG_LCR_THRE 1 5 <<
#define UART_REG_LSR_DR 1


\ "ns16550a compatible" UART DRIVER

CODE initUart
    # taken from https://github.com/safinsingh/ns16550a/tree/master
    # Args:
    # a0 - UART base address
    mv  t0, a0
80000008	82AA	c.mv	t0,a0

    # 0x3 -> 8 bit word length
    li  t1, 0x3
8000000A	430D		c.li	t1,3
    sb  t1, UART_REG_LCR(t0)
8000000C	81A3 0062	sb	t1,3(t0)

    # 0x1 -> enable FIFOs
    li  t1, 0x1
80000010	4305		c.li	t1,1
    sb  t1, UART_REG_LCR(t0)
80000012	81A3 0062	sb	t1,3(t0)

    # 0x1 -> enable reciever interrupts
    sb  t1, UART_REG_IER(t0)
80000016	80A3 0062	sb	t1,1(t0)
    ret
8000001A	8082		ret
END-CODE

CODE putc
    # Args:
    # a0 - character to output
    # a1 - UART base address
    addi sp, sp, -16  # allocate 16 bytes on stack
8000001C	1141		c.addi	sp,-16
    sw   ra, 12(sp)   # store return address on stack
8000001E	C606		c.swsp	s1,12(sp)

0:
    lb t0, UART_REG_LCR(a1)
80000020	8283 0035	lb	t0,3(a1)
    andi t1, t0, UART_REG_LCR_THRE
80000024	F313 0202	andi	t1,t0,32
    beqz t1, 1f
80000028	0363 0003	beq	t1,zero,0x8000002E
    j 0b
8000002C	BFD5	c.j	0x80000020
1:
    sb a0, UART_REG_TRANSMIT(a1)
8000002E	8023 00A5	sb	a0,0(a1)

    lw   ra, 12(sp)  # load return address from stack
80000032	40B2		c.lwsp	s1,12(sp)
    addi sp, sp, 16  # restore stack pointer
80000034	0141		c.addi	sp,16
    ret
80000036	8082		ret

END-CODE

CODE puts
    # Args:
    # a0 - string address
    # a1 - UART base address
    # while string byte not null
    SaveReturnAddress
80000038	1141		c.addi	sp,-16
8000003A	C606		c.swsp	s1,12(sp)
    mv t3, a0
8000003C	8E2A	c.mv	t3,a0
1:
    lb t0, 0(t3)
8000003E	0283 000E	lb	t0,0(t3)
    beq t0, zero, 2f
80000042	8663 0002	beq	t0,zero,0x8000004E
    mv a0, t0
80000046	8516	c.mv	a0,t0
    call ' putc
80000048	3FD1	c.jal	0x8000001C
    addi t3, t3, 1
8000004A	0E05		c.addi	t3,1
    j 1b
8000004C	BFCD	c.j	0x8000003E
2:
    RestoreReturnAddress
8000004E	40B2		c.lwsp	s1,12(sp)
80000050	0141		c.addi	sp,16
    ret
80000052	8082		ret

END-CODE

CODE getc
    # Args:
    # a0 - UART base address
    # Returns:
    # a0 - char from uart
    SaveReturnAddress
80000054	1141		c.addi	sp,-16
80000056	C606		c.swsp	s1,12(sp)
    add sp, sp, -8
80000058	1161		c.addi	sp,-8
    sw t0, 0(sp)
8000005A	C016		c.swsp	a3,0(sp)
    sw t1, 4(sp)
8000005C	C21A		c.swsp	a4,4(sp)
    lbu t0, UART_REG_LSR(a0)
8000005E	4283 0055	lbu	t0,5(a0)
    andi t1, t0, UART_REG_LSR_DR
80000062	F313 0012	andi	t1,t0,1
    beqz t1, 1f \ bytenotread
80000066	0363 0003	beq	t1,zero,0x8000006C
    j 0f \ byteread
8000006A	A019	c.j	0x80000070
1: \ bytenotread:
    li a0, 0
8000006C	4501		c.li	a0,0
    j 2f \ end
8000006E	A019	c.j	0x80000074
0: \ byteread:
    lb a0, UART_REG_RECEIVE(a0)
80000070	0503 0005	lb	a0,0(a0)
2: \ end:
    lw t0, 0(sp)
80000074	4282		c.lwsp	a3,0(sp)
    lw t1, 4(sp)
80000076	4312		c.lwsp	a4,4(sp)
    add sp, sp, 8
80000078	0121		c.addi	sp,8
    RestoreReturnAddress
8000007A	40B2		c.lwsp	s1,12(sp)
8000007C	0141		c.addi	sp,16
    ret
8000007E	8082		ret

END-CODE

CODE getc_block
    # Args:
    # a0 - UART base address
    # Returns:
    # a0 - char from uart
    SaveReturnAddress
80000080	1141		c.addi	sp,-16
80000082	C606		c.swsp	s1,12(sp)
    mv t0, a0
80000084	82AA	c.mv	t0,a0
4:
    mv a0, t0
80000086	8516	c.mv	a0,t0
    call  ' getc
80000088	37F1	c.jal	0x80000054
    beqz a0, 4b \  ' notgotchar
8000008A	DD75	c.beqz	a0,0x80000086
    RestoreReturnAddress
8000008C	40B2		c.lwsp	s1,12(sp)
8000008E	0141		c.addi	sp,16
    ret
80000090	8082		ret
END-CODE
